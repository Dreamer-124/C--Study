# C-Plus-Plus-Study
该仓库用于记录对C++的重新学习，学习课程为[B站cherno的C++课程](https://www.bilibili.com/video/BV1Dk4y1j7oj?spm_id_from=333.788.player.switch&vd_source=84ff7634bfae1f81c7d0f8c6720a9747&p=3)

# 知识回顾
## C++的一些主要优点是什么？
- 可以直接操作硬件，好的C++代码运行速度会很快，但是不好的C++代码运行速度会很慢，适应于高性能场景
- 直接从源代码通过编译器生成相应平台的可执行文件，具有良好的可移植性和泛化性

## C++是如何工作的？
- .cpp文件编写完 -> 将文件丢给编译器 -> 编译器对需要预处理的内容进行预处理 -> 编译器根据配置为每一个.cpp文件生成一个.obj文件 -> 链接器将所有的.obj文件合成为一个.exe文件 -> 执行.exe文件

## C++编译器是如何工作的？
- .cpp和.h文件编写完 -> 编译器将其转换为二进制的.obj文件
- Vs中可以使用优化器来对当前的代码在编译的时候进行优化，确保其转换为.obj文件的时候可以得到最优的汇编文件，执行起来会很快的汇编文件
- 预处理过程中#include "xxx.h"会将头文件的内容复制粘贴到当前位置 -> #if 1 ... #endif 来确保哪段代码是被编译或者禁用的 -> #define A B 用于将A替换为B

## C++链接器是如何工作的？
- 链接器通过将所有的.obj文件中的函数和符号进行链接，从而生成可执行文件
- 编译阶段的报错是以C开头的，链接阶段的报错是以LINK开头的
- 如果出现链接错误，我们可以使用static、inline关键字或者使用 .h文件进行声明来解决

## C++变量
- 在使用变量时是会在计算机内部进行内存分配，变量的数据类型不同，分配的内存大小也不同。
- 所有的数据类型都可以分为无符号数和有符号数
- 不同的编译器对数据类型的大小定义不同，可以通过sizeof进行查看

## C++函数
- 函数的主要目的是防止代码重复
- 每次调用函数的时候，都会生成一个call指令，然后申请一个堆栈，将传入的参数压入堆栈中，最后根据返回地址获取最后的返回值。
- 函数实际上是在内存中跳转执行，调用函数的次数越多，程序就会越慢

## C++头文件
- 头文件通常用于声明函数，使其可以被用于我们的程序中
- #pragma once和#ifndef _LOG_H #define _LOG_H #endif用于监督当前头文件只被使用了一次
- #include后面的""通常指明包含相对于当前文件的文件，<>通常指搜索编译器包含路径文件夹
- C++标准库和C标准库的区别是有没有后面的扩展

## 如何在Visual Studio中调试代码
- 调试最重要的两个部分是断点和读取内存
- 未初始化的栈内存在内存中的表示是大量的0xCC
- 一个程序就是由内存组成的，还有指令指针，所以在我们调试代码的时候，可以看到内存是很重要的

## C++条件与分支（if语句）
- if语句具有很大的开销，因为他需要进行跳转，所以当写一些高性能的代码的时候，尽可能不用if语句
- 可以尝试用数学编程去替代逻辑编程，因为逻辑编程会在一定程度上降低运行速度
- 我们可以通过反汇编来查看当前代码在电脑中是如何运行的从而对自己的代码做出优化（此前提需要确保编译器没有进行自主优化汇编代码）

## Visual Studio的最佳设置
- "显示所有文件"可以让我们更好的组织我们的代码
- 清晰的项目组织在编写代码时非常重要，要通过合理地设置编译器选项来完成自己的项目组织

## C++循环
- for中包含声明语句、条件语句以及最后的执行语句
- while中只包含条件语句
- do while中条件语句会在执行语句之后进行判断

## C++控制流语句
- 控制流语句包含continue，break，return

## C++指针
- 一个指针只是一个地址，它是一个保存内存地址的整数
- 可以将计算机的内存想象成一个线性的街道，每一个字节的内存都是一栋房子，对于每一栋房子我们会有指定的地址
- 我们声明一个变量的时候一般是在栈上创建的，而当我们手动分配和释放内存的时候，这个是都是在堆内存上创建的

## C++引用
- 引用本质上是指针的扩展
- 引用不占用内存，没有真正的存储空间
- 声明引用的时候，必须进行初始化
- 一旦我们声明 了一个引用，我们不能改变它引用的东西
- 引用可以做的，也可以使用指针来做，但是一般而言，引用做起来可以更加的简便，易读 

## C++类
- 默认情况下，一个类中所有的东西都是私有的，也就是说只有类中的方法可以访问类中定义的变量
- 类允许我们将变量分组到一个类型中，并为这些变量添加功能，可以使我们的代码更加简洁，优雅，更易于维护
- 注意：可以用类搞定的事情，不用类一样搞得定

## C++类与结构体对比
- 类与结构体的区别只在于可见度，在技术上本质是一样的，结构体中的成员和方法默认是public的
- C++中保留结构体是为了保留与C语言的向后兼容性
- 当我们要创建只有变量的结构的时候，我们使用struct
- 当我们要创建具有方法、成员以及该组织需要可以被继承的时候，我们使用class

## 如何写一个C++类
- 尽可能把类中的每一个部分都分开写

## C++中的静态（static）
- 在类或结构体外部使用static关键字，意味着声明为static的符号，只对当前文件可见
- 在类或结构体内部使用static关键字，以为着声明为static的符号实际上将与类的所有实例共享内存
- 在正常的编译链接过程中，我们不能有两个同名的全局变量，但是可以使用static或者extern进行处理
- 全局变量一般不建议使用

## C++类和结构体中的静态（Static）
- 在类和结构体内部的静态声明的对象是全局的，即所有的类或者结构体共享同一个静态对象
- 代码要有组织，有规划
- 静态方法是没有类实例的
- 静态方法是不可以访问非静态成员的

## C++中的局部静态（Local Static）
- 静态局部变量的生存期相当于整个程序的生存期
- 静态局部变量可以声明在程序的任何地方

## C++枚举
- 枚举是一个数值集合，是一种命名值的方法，当我们想要用整数来表示某些状态或者某些数值时，它非常有用。

## C++构造函数
- 对于类而言，我们创建一个新对象实例时，构造函数会自动运行，C++默认有一个空的构造函数
- 在构造函数中，我们可以进行我们对该类想要进行处理的所有初始化

## C++析构函数
- 析构函数是在一个对象要被销毁的时候运行的
- 析构函数的方法名：~类名

## C++继承
- 继承可以避免代码重复
- 当你创建一个子类的时候，这个子类将包含它父类中的所有内容
- 类的大小和内存是可以变化的

## C++虚函数
- 虚函数允许我们在子类中重写方法
- 我们在类内部声明函数的时候，函数通常在类内部（起作用），要调用方法的时候，会调用属于该类型的方法
- 虚函数引入了动态联编，通过v表（虚函数表）来实现编译
- 虚函数表包含基类中所有虚函数的映射
- 如果我们想要重写一个函数的时候，我们必须将基类中的基函数标记为虚函数
- 虚函数因为需要额外的指针指向v表，并且需要遍历v表来确保要被重写的函数可以正确地被找到，所以会产生额外的开销，因此在CPU性能差的机器上(比如某些嵌入式平台)，尽量避免使用虚函数 

##  C++接口（纯虚函数）
- 纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数
- 只有实现了所有的纯虚函数后，才能够实例化，即创建这个类的实例
```C++
// 定义一个虚函数的类，并且创建一个子类继承它
class Printtable
{
public:
    virtual std::string GetClassName() = 0;  // 定义一个虚函数    
}

class Entity : public Printtable
{
public:
    std::string GetClassName() {return "Entity";}
}
```

## C++可见性
- 一个对象的可见性，是指谁能看到它们，谁能调用它们，谁能使用它们
- C++中的三个基础可见性修饰符是private, protected, public
- friend可以从类中访问私有成员
- 可见性可以确保人们不会调用不应该调用的代码，这些代码可能会破坏某些东西
```C++
class Entity
{
private:  // 只有在当前类内部可以访问
    int X, Y;
protected:  // 当前类和子类都可以进行访问
    void Print()
    {

    }
public:  // 可以被公开访问
    void Entity()
    {
        x = 0;
    }
}
```

## C++数组
- 尽可能在for循环中条件判别式中不要用多重判别，比如 <= ，因为这样会降低程序性能
- 数组是连续的存储数据
- new申请的内存的生存周期是一直到你用delete删除它
- 尽可能在栈上创建数组来避免内存间接寻址，因为在内存中跳跃肯定会影响性能
- 在C++11中，标准数组std::array可以被用来代替这里展示的原始数组，这样会更加安全，但是肯定会有额外的开销
```C++
std::array <int, 5> another;

for(int i = 0; i < another.size(); i++)
{
    another[i] = 2;
}
```

## C++字符串
